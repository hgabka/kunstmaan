<?php

use Symfony\Component\Yaml\Yaml;
use Symfony\Component\Yaml\Exception\ParseException;

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/*
 * Users of PHP 5.2 should be able to run the requirements checks.
 * This is why the file and all classes must be compatible with PHP 5.2+
 * (e.g. not using namespaces and closures).
 *
 * ************** CAUTION **************
 *
 * DO NOT EDIT THIS FILE as it will be overridden by Composer as part of
 * the installation/update process. The original file resides in the
 * SensioDistributionBundle.
 *
 * ************** CAUTION **************
 */

/**
 * Represents a single PHP requirement, e.g. an installed extension.
 * It can be a mandatory requirement or an optional recommendation.
 * There is a special subclass, named PhpIniRequirement, to check a php.ini configuration.
 *
 * @author Tobias Schultze <http://tobion.de>
 */
class Requirement
{
    private $fulfilled;
    private $testMessage;
    private $helpText;
    private $helpHtml;
    private $optional;

    /**
     * Constructor that initializes the requirement.
     *
     * @param bool        $fulfilled   Whether the requirement is fulfilled
     * @param string      $testMessage The message for testing the requirement
     * @param string      $helpHtml    The help text formatted in HTML for resolving the problem
     * @param string|null $helpText    The help text (when null, it will be inferred from $helpHtml, i.e. stripped from HTML tags)
     * @param bool        $optional    Whether this is only an optional recommendation not a mandatory requirement
     */
    public function __construct($fulfilled, $testMessage, $helpHtml, $helpText = null, $optional = false)
    {
        $this->fulfilled = (bool) $fulfilled;
        $this->testMessage = (string) $testMessage;
        $this->helpHtml = (string) $helpHtml;
        $this->helpText = null === $helpText ? strip_tags($this->helpHtml) : (string) $helpText;
        $this->optional = (bool) $optional;
    }

    /**
     * Returns whether the requirement is fulfilled.
     *
     * @return bool true if fulfilled, otherwise false
     */
    public function isFulfilled()
    {
        return $this->fulfilled;
    }

    /**
     * Returns the message for testing the requirement.
     *
     * @return string The test message
     */
    public function getTestMessage()
    {
        return $this->testMessage;
    }

    /**
     * Returns the help text for resolving the problem.
     *
     * @return string The help text
     */
    public function getHelpText()
    {
        return $this->helpText;
    }

    /**
     * Returns the help text formatted in HTML.
     *
     * @return string The HTML help
     */
    public function getHelpHtml()
    {
        return $this->helpHtml;
    }

    /**
     * Returns whether this is only an optional recommendation and not a mandatory requirement.
     *
     * @return bool true if optional, false if mandatory
     */
    public function isOptional()
    {
        return $this->optional;
    }
}

/**
 * Represents a PHP requirement in form of a php.ini configuration.
 *
 * @author Tobias Schultze <http://tobion.de>
 */
class PhpIniRequirement extends Requirement
{
    /**
     * Constructor that initializes the requirement.
     *
     * @param string        $cfgName           The configuration name used for ini_get()
     * @param bool|callback $evaluation        Either a boolean indicating whether the configuration should evaluate to true or false,
     *                                         or a callback function receiving the configuration value as parameter to determine the fulfillment of the requirement
     * @param bool          $approveCfgAbsence If true the Requirement will be fulfilled even if the configuration option does not exist, i.e. ini_get() returns false.
     *                                         This is helpful for abandoned configs in later PHP versions or configs of an optional extension, like Suhosin.
     *                                         Example: You require a config to be true but PHP later removes this config and defaults it to true internally.
     * @param string|null   $testMessage       The message for testing the requirement (when null and $evaluation is a boolean a default message is derived)
     * @param string|null   $helpHtml          The help text formatted in HTML for resolving the problem (when null and $evaluation is a boolean a default help is derived)
     * @param string|null   $helpText          The help text (when null, it will be inferred from $helpHtml, i.e. stripped from HTML tags)
     * @param bool          $optional          Whether this is only an optional recommendation not a mandatory requirement
     */
    public function __construct($cfgName, $evaluation, $approveCfgAbsence = false, $testMessage = null, $helpHtml = null, $helpText = null, $optional = false)
    {
        $cfgValue = ini_get($cfgName);

        if (is_callable($evaluation)) {
            if (null === $testMessage || null === $helpHtml) {
                throw new InvalidArgumentException('You must provide the parameters testMessage and helpHtml for a callback evaluation.');
            }

            $fulfilled = call_user_func($evaluation, $cfgValue);
        } else {
            if (null === $testMessage) {
                $testMessage = sprintf('A %s %s be %s in php.ini',
                    $cfgName,
                    $optional ? 'ajánlott' : 'szükséges',
                    $evaluation ? 'bekapcsolni' : 'kikapcsolni'
                );
            }

            if (null === $helpHtml) {
                $helpHtml = sprintf('Kapcsolja <strong>%s</strong> a <strong>%s</strong> beállítást a php.ini-ben<a href="#phpini">*</a>.',
                  $evaluation ? 'be' : 'ki',
                    $cfgName
                );
            }

            $fulfilled = $evaluation == $cfgValue;
        }

        parent::__construct($fulfilled || ($approveCfgAbsence && false === $cfgValue), $testMessage, $helpHtml, $helpText, $optional);
    }
}

/**
 * A RequirementCollection represents a set of Requirement instances.
 *
 * @author Tobias Schultze <http://tobion.de>
 */
class RequirementCollection implements IteratorAggregate
{
    private $requirements = array();

    /**
     * Gets the current RequirementCollection as an Iterator.
     *
     * @return Traversable A Traversable interface
     */
    public function getIterator()
    {
        return new ArrayIterator($this->requirements);
    }

    /**
     * Adds a Requirement.
     *
     * @param Requirement $requirement A Requirement instance
     */
    public function add(Requirement $requirement)
    {
        $this->requirements[] = $requirement;
    }

    /**
     * Adds a mandatory requirement.
     *
     * @param bool        $fulfilled   Whether the requirement is fulfilled
     * @param string      $testMessage The message for testing the requirement
     * @param string      $helpHtml    The help text formatted in HTML for resolving the problem
     * @param string|null $helpText    The help text (when null, it will be inferred from $helpHtml, i.e. stripped from HTML tags)
     */
    public function addRequirement($fulfilled, $testMessage, $helpHtml, $helpText = null)
    {
        $this->add(new Requirement($fulfilled, $testMessage, $helpHtml, $helpText, false));
    }

    /**
     * Adds an optional recommendation.
     *
     * @param bool        $fulfilled   Whether the recommendation is fulfilled
     * @param string      $testMessage The message for testing the recommendation
     * @param string      $helpHtml    The help text formatted in HTML for resolving the problem
     * @param string|null $helpText    The help text (when null, it will be inferred from $helpHtml, i.e. stripped from HTML tags)
     */
    public function addRecommendation($fulfilled, $testMessage, $helpHtml, $helpText = null)
    {
        $this->add(new Requirement($fulfilled, $testMessage, $helpHtml, $helpText, true));
    }

    /**
     * Adds a mandatory requirement in form of a php.ini configuration.
     *
     * @param string        $cfgName           The configuration name used for ini_get()
     * @param bool|callback $evaluation        Either a boolean indicating whether the configuration should evaluate to true or false,
     *                                         or a callback function receiving the configuration value as parameter to determine the fulfillment of the requirement
     * @param bool          $approveCfgAbsence If true the Requirement will be fulfilled even if the configuration option does not exist, i.e. ini_get() returns false.
     *                                         This is helpful for abandoned configs in later PHP versions or configs of an optional extension, like Suhosin.
     *                                         Example: You require a config to be true but PHP later removes this config and defaults it to true internally.
     * @param string        $testMessage       The message for testing the requirement (when null and $evaluation is a boolean a default message is derived)
     * @param string        $helpHtml          The help text formatted in HTML for resolving the problem (when null and $evaluation is a boolean a default help is derived)
     * @param string|null   $helpText          The help text (when null, it will be inferred from $helpHtml, i.e. stripped from HTML tags)
     */
    public function addPhpIniRequirement($cfgName, $evaluation, $approveCfgAbsence = false, $testMessage = null, $helpHtml = null, $helpText = null)
    {
        $this->add(new PhpIniRequirement($cfgName, $evaluation, $approveCfgAbsence, $testMessage, $helpHtml, $helpText, false));
    }

    /**
     * Adds an optional recommendation in form of a php.ini configuration.
     *
     * @param string        $cfgName           The configuration name used for ini_get()
     * @param bool|callback $evaluation        Either a boolean indicating whether the configuration should evaluate to true or false,
     *                                         or a callback function receiving the configuration value as parameter to determine the fulfillment of the requirement
     * @param bool          $approveCfgAbsence If true the Requirement will be fulfilled even if the configuration option does not exist, i.e. ini_get() returns false.
     *                                         This is helpful for abandoned configs in later PHP versions or configs of an optional extension, like Suhosin.
     *                                         Example: You require a config to be true but PHP later removes this config and defaults it to true internally.
     * @param string        $testMessage       The message for testing the requirement (when null and $evaluation is a boolean a default message is derived)
     * @param string        $helpHtml          The help text formatted in HTML for resolving the problem (when null and $evaluation is a boolean a default help is derived)
     * @param string|null   $helpText          The help text (when null, it will be inferred from $helpHtml, i.e. stripped from HTML tags)
     */
    public function addPhpIniRecommendation($cfgName, $evaluation, $approveCfgAbsence = false, $testMessage = null, $helpHtml = null, $helpText = null)
    {
        $this->add(new PhpIniRequirement($cfgName, $evaluation, $approveCfgAbsence, $testMessage, $helpHtml, $helpText, true));
    }

    /**
     * Adds a requirement collection to the current set of requirements.
     *
     * @param RequirementCollection $collection A RequirementCollection instance
     */
    public function addCollection(RequirementCollection $collection)
    {
        $this->requirements = array_merge($this->requirements, $collection->all());
    }

    /**
     * Returns both requirements and recommendations.
     *
     * @return array Array of Requirement instances
     */
    public function all()
    {
        return $this->requirements;
    }

    /**
     * Returns all mandatory requirements.
     *
     * @return array Array of Requirement instances
     */
    public function getRequirements()
    {
        $array = array();
        foreach ($this->requirements as $req) {
            if (!$req->isOptional()) {
                $array[] = $req;
            }
        }

        return $array;
    }

    /**
     * Returns the mandatory requirements that were not met.
     *
     * @return array Array of Requirement instances
     */
    public function getFailedRequirements()
    {
        $array = array();
        foreach ($this->requirements as $req) {
            if (!$req->isFulfilled() && !$req->isOptional()) {
                $array[] = $req;
            }
        }

        return $array;
    }

    /**
     * Returns all optional recommendations.
     *
     * @return array Array of Requirement instances
     */
    public function getRecommendations()
    {
        $array = array();
        foreach ($this->requirements as $req) {
            if ($req->isOptional()) {
                $array[] = $req;
            }
        }

        return $array;
    }

    /**
     * Returns the recommendations that were not met.
     *
     * @return array Array of Requirement instances
     */
    public function getFailedRecommendations()
    {
        $array = array();
        foreach ($this->requirements as $req) {
            if (!$req->isFulfilled() && $req->isOptional()) {
                $array[] = $req;
            }
        }

        return $array;
    }

    /**
     * Returns whether a php.ini configuration is not correct.
     *
     * @return bool php.ini configuration problem?
     */
    public function hasPhpIniConfigIssue()
    {
        foreach ($this->requirements as $req) {
            if (!$req->isFulfilled() && $req instanceof PhpIniRequirement) {
                return true;
            }
        }

        return false;
    }

    /**
     * Returns the PHP configuration file (php.ini) path.
     *
     * @return string|false php.ini file path
     */
    public function getPhpIniConfigPath()
    {
        return get_cfg_var('cfg_file_path');
    }
}

/**
 * This class specifies all requirements and optional recommendations that
 * are necessary to run Kunstmaan.
 *
 * @author Tobias Schultze <http://tobion.de>
 * @author Fabien Potencier <fabien@symfony.com>
 */
class KunstmaanRequirements extends RequirementCollection
{
    const REQUIRED_PHP_VERSION = '5.6.0';
    const REQUIRED_LIBXML_VERSION = '2.6.21';
    
    
    protected $requiredFunctions = array(
        'iconv' => 'iconv',
        'json_encode' => 'JSON',
        'ctype_alpha' => 'ctype',
        'curl_version' => 'curl',
        'pcntl_fork' => 'pcntl',
        'utf8_decode' => 'XML',
        'token_get_all' => 'Tokenizer',
        'mb_strlen' => 'mbstring',
        'apcu_add' => 'APCu',
        'simplexml_import_dom' => 'SimpleXML',
    );
    
    protected $requiredExtensions = array(
        'gd',
        'imagick',
        'memcached',
        'libxml',
        'posix',
        'pdo_mysql',
        'intl',
    );

     protected $whiches = array(
        'which',
        'bundle',
        'npm',
        'bower',
        'node',
        'nodejs',
        'uglifyjs',
        'uglifycss',
        'sass',
        'gulp',
        'composer',
    );

    protected $parameters;

    protected $elasticHost;
    protected $elasticPort;

    /**
     * Constructor that initializes the requirements.
     */
    public function __construct($elasticHost, $elasticPort)
    {
        require_once __DIR__.'/../vendor/autoload.php';
        try {
            $params = Yaml::parse(file_get_contents(__DIR__.'/config/parameters.yml.dist'));
        } catch (ParseException $e) {
            printf("Unable to parse the YAML string: %s", $e->getMessage());
            exit;
        }
        $this->parameters = $params['parameters'];

        $this->elasticHost = empty($elasticHost) ? 'localhost' : $elasticHost;
        $this->elasticPort = empty($elasticPort) ? '9200' : $elasticPort;


        /* mandatory requirements follow */

        $installedPhpVersion = phpversion();

        $this->addRequirement(
            version_compare($installedPhpVersion, self::REQUIRED_PHP_VERSION, '>='),
            sprintf('PHP verzió minimum %s (a szerveren %s van)', self::REQUIRED_PHP_VERSION, $installedPhpVersion),
            sprintf('A szerver PHP verziója "<strong>%s</strong>", de a Kunstmaan működéséhez minimum "<strong>%s</strong>" szükséges.',
                $installedPhpVersion, self::REQUIRED_PHP_VERSION),
            null
        );


        if (version_compare($installedPhpVersion, '7.0.0', '<')) {
            $this->addPhpIniRequirement(
                'date.timezone', true, false,
                'A date.timezone php.ini beállítás hiányzik',
                'Állítsa be a "<strong>date.timezone</strong>" -t a php.ini fájlban<a href="#phpini">*</a> (pl. Europe/Budapest).'
            );
        }

        if (version_compare($installedPhpVersion, self::REQUIRED_PHP_VERSION, '>=')) {
            $timezones = array();
            foreach (DateTimeZone::listAbbreviations() as $abbreviations) {
                foreach ($abbreviations as $abbreviation) {
                    $timezones[$abbreviation['timezone_id']] = true;
                }
            }

            $this->addRequirement(
                isset($timezones[@date_default_timezone_get()]),
                sprintf('A beállított időzóna "%s" nem támogatott', @date_default_timezone_get()),
                'A <strong>php.ini</strong>-ben  beállított időzóna nem támogatott. Az érvényes időzónák listáját itt találja: <a href="http://php.net/manual/en/timezones.others.php">http://php.net/manual/en/timezones.others.php</a>.'
            );
        }
        
        foreach ($this->requiredFunctions as $function => $extension)
        {
            $this->checkExtensionWithFunction($function, $extension);
        }

        foreach ($this->requiredExtensions as $extension)
        {
            $this->checkExtension($extension);
        }
        
        if (extension_loaded('libxml'))
        {
            $this->addRequirement(
                version_compare(LIBXML_DOTTED_VERSION, '2.6.21',  '>='),
                sprintf('libxml verzió minimum %s (a szerveren %s van)', self::REQUIRED_LIBXML_VERSION, LIBXML_DOTTED_VERSION),
                sprintf('A szerver libxml verziója "<strong>%s</strong>", de a Kunstmaan működéséhez minimum "<strong>%s</strong>" szükséges.',
                    self::REQUIRED_LIBXML_VERSION, LIBXML_DOTTED_VERSION),
                null
            );
        }

        $this->addPhpIniRequirement('detect_unicode', false);

        $pcreVersion = defined('PCRE_VERSION') ? (float) PCRE_VERSION : null;

        $this->addRequirement(
            null !== $pcreVersion,
            'A PCRE kiterjesztést telepíteni szükséges',
            'Telepítse a <strong>PCRE</strong> kiterjesztést (8.0+ verzió).'
        );

        if (extension_loaded('mbstring')) {
            $this->addPhpIniRequirement(
                'mbstring.func_overload',
                create_function('$cfgValue', 'return (int) $cfgValue === 0;'),
                true,
                'Az mbstring.func_overload PHP ini beállítás nem megfelelő',
                'A "<strong>mbstring.func_overload</strong>" php.ini<a href="#phpini">*</a> beállítás értéke legyen <strong>0</strong>.'
            );
        }

        $result = $this->executeCommand("convert -version");

        $this->addRequirement(
            $result['code'] === 0,
            'Az ImageMagick nincs teleítve a szerveren',
            'Telepítse az <strong>ImageMagick</strong> programot.',
            null);

        $curlPath = $this->executeWhich('curl');
        $this->addRequirement(
            !empty($curlPath),
            'A "curl" parancs nincs telepítve',
            'Telepítse a <strong>curl</strong> parancsot',
            null
        );

        $result = $this->checkElastic();

        $this->addRequirement(
          $result !== false,
          'Az elasticsearch nincs telepítve, vagy nem megfelelő a host és a port',
          'Telepítse az elasticsearch programot, vagy adja meg a host és a port helyes értékét.',
          null);

        $mysqlVersions = $this->getMysqlVersion();

        $this->addRequirement(
            version_compare($mysqlVersions['real'], '5.0', '>='),
            sprintf('A Mysql szerver verziója túl alacsony (%s)',$mysqlVersions['real'] ),
            sprintf('A mysql szerver verziójának minimum 5.x-nek kell lennie (a szerveren lévő verzió: <strong>%s</strong>).',$mysqlVersions['real'] ),
            null);


        /* optional recommendations follow */


        $this->addRecommendation($mysqlVersions['real'] == $mysqlVersions['params'],
          sprintf('A mysql szerver verziója %s, de a parameters.yml.dist fájlban %s van megadva.',$mysqlVersions['real'],$mysqlVersions['params'] ),
          sprintf('A mysql szerver verziója <strong>%s</strong>, de a parameters.yml.dist fájlban <strong>%s</strong> van megadva.',$mysqlVersions['real'],$mysqlVersions['params'] ),
          null);

        if (null !== $pcreVersion) {
            $this->addRecommendation(
                $pcreVersion >= 8.0,
                sprintf('A PCRE kiterjesztés verziója kissebb, mint 8.0 (%s)', $pcreVersion),
                '<strong>PCRE 8.0+</strong> a PHP 5.3.2-es verziója óta előre konfigurált, de a szerveren egy régebbi verzió van. A Symfony működni fog, de ajánlott a frissítés.'
            );
        }

        $this->addRecommendation(
            class_exists('DomDocument'),
            'A PHP-DOM és PHP-XML modulokat ajánlott telepíteni',
            'Telepítse és engedélyezze a <strong>PHP-DOM</strong> és <strong>PHP-XML</strong> modulokat.'
        );


        $this->addRecommendation(
            function_exists('filter_var'),
            'A filter_var() függvény nem elérhető',
            'Telepítse és engedélyezzes a <strong>filter</strong> PHP kiterjesztést.'
        );

        if (!defined('PHP_WINDOWS_VERSION_BUILD')) {
            $this->addRecommendation(
                function_exists('posix_isatty'),
                'posix_isatty() should be available',
                'Install and enable the <strong>php_posix</strong> extension (used to colorize the CLI output).'
            );
        }



        if (extension_loaded('intl')) {
            // in some WAMP server installations, new Collator() returns null
            $this->addRecommendation(
                null !== new Collator('fr_FR'),
                'intl extension should be correctly configured',
                'The intl extension does not behave properly. This problem is typical on PHP 5.3.X x64 WIN builds.'
            );

            // check for compatible ICU versions (only done when you have the intl extension)
            if (defined('INTL_ICU_VERSION')) {
                $version = INTL_ICU_VERSION;
            } else {
                $reflector = new ReflectionExtension('intl');

                ob_start();
                $reflector->info();
                $output = strip_tags(ob_get_clean());

                preg_match('/^ICU version +(?:=> )?(.*)$/m', $output, $matches);
                $version = $matches[1];
            }

            $this->addRecommendation(
                version_compare($version, '4.0', '>='),
                'intl ICU verziószám legalább 4+ kell, hogy legyen',
                'Frissítse az <strong>intl</strong> kiterjesztést egy újabb verziójú <strong>ICU</strong>-val (4+).'
            );

            if (class_exists('Symfony\Component\Intl\Intl')) {
                $this->addRecommendation(
                    \Symfony\Component\Intl\Intl::getIcuDataVersion() === \Symfony\Component\Intl\Intl::getIcuVersion(),
                    sprintf('Az intl ICU verziónak (%s) meg kell egyeznie a Symfony-ban tárolt értékkel (%s)', \Symfony\Component\Intl\Intl::getIcuVersion(), \Symfony\Component\Intl\Intl::getIcuDataVersion()),
                    sprintf('Általában nem jelent problémát, de ellenőrizze, hogy nincs-e ütközés a Symfony-s intl adatokkal (szerver: %s, Symfony: %s)(https://github.com/symfony/symfony/issues/15007).',\Symfony\Component\Intl\Intl::getIcuVersion(), \Symfony\Component\Intl\Intl::getIcuDataVersion())
                );
            }

            $this->addPhpIniRecommendation(
                'intl.error_level',
                create_function('$cfgValue', 'return (int) $cfgValue === 0;'),
                true,
                'intl.error_level should be 0 in php.ini',
                'Set "<strong>intl.error_level</strong>" to "<strong>0</strong>" in php.ini<a href="#phpini">*</a> to inhibit the messages when an error occurs in ICU functions.'
            );
        }

        $accelerator =
            (extension_loaded('eaccelerator') && ini_get('eaccelerator.enable'))
            ||
            (extension_loaded('apc') && ini_get('apc.enabled'))
            ||
            (extension_loaded('Zend Optimizer+') && ini_get('zend_optimizerplus.enable'))
            ||
            (extension_loaded('Zend OPcache') && ini_get('opcache.enable'))
            ||
            (extension_loaded('xcache') && ini_get('xcache.cacher'))
            ||
            (extension_loaded('wincache') && ini_get('wincache.ocenabled'))
        ;

        $this->addRecommendation(
            $accelerator,
            'a PHP accelerator should be installed',
            'Telepítsen egy <strong>PHP gyorsítót</strong> (erősen ajánlott).'
        );

        if (strtoupper(substr(PHP_OS, 0, 3)) === 'WIN') {
            $this->addRecommendation(
                $this->getRealpathCacheSize() > 1000,
                'A realpath_cache_size php.ini beállításnak nagyobbnak kell lennie, mint 1024',
                'Állítsa be a "<strong>realpath_cache_size</strong>" php.ini<a href="#phpini">*</a> beállítás értékét "<strong>1024</strong>"-re a teljesítmény növelése érdekében.'
            );
        }

        $this->addPhpIniRecommendation('short_open_tag', false);

        $this->addPhpIniRecommendation('magic_quotes_gpc', false, true);

        $this->addPhpIniRecommendation('register_globals', false, true);

        $this->addPhpIniRecommendation('session.auto_start', false);

        $this->addRecommendation(
            class_exists('PDO'),
            'A PDO kiterjesztést telepíteni szükséges',
            'Telepítse a <strong>PDO</strong> PHP kiterjesztést.'
        );

        if (class_exists('PDO')) {
            $drivers = PDO::getAvailableDrivers();
            $this->addRecommendation(
                count($drivers) > 0,
                sprintf('PDO driverek hiányoznak (telepítve: %s)', count($drivers) ? implode(', ', $drivers) : 'none'),
                'Telepítse a <strong>PDO drivereket</strong> (mandatory for Doctrine).'
            );
        }

        foreach ($this->getWhiches($this->whiches) as $file => $path)
        {
            $this->addRecommendation(
              !empty($path),
              sprintf('A(z)"%s" program nem elérhető', $file),
              sprintf('Telepítse a(z) <strong>%s</strong> programot', $file)
            );
        }
    }

    /**
     * Loads realpath_cache_size from php.ini and converts it to int.
     *
     * (e.g. 16k is converted to 16384 int)
     *
     * @return int
     */
    protected function getRealpathCacheSize()
    {
        $size = ini_get('realpath_cache_size');
        $size = trim($size);
        $unit = strtolower(substr($size, -1, 1));
        switch ($unit) {
            case 'g':
                return $size * 1024 * 1024 * 1024;
            case 'm':
                return $size * 1024 * 1024;
            case 'k':
                return $size * 1024;
            default:
                return (int) $size;
        }
    }
    
    protected function checkExtension($extension)
    {
        $this->addRequirement(
            extension_loaded($extension),
            'A '.$extension.' kiterjesztés nem elérhető',
            'A <strong>'.$extension.'</strong> PHP kiterjesztést telepíteni és engedélyezni szükséges.'
        );
    }
    
    protected function checkExtensionWithFunction($function, $extension)
    {
        $this->addRequirement(
            function_exists($function),
            'A '.$function.'() függvény nem elérhető',
            'A <strong>'.$extension.'</strong> PHP kiterjesztést telepíteni és engedélyezni szükséges.'
        );
        
    }

    protected function getMysqlVersion()
    {
        $port = $this->parameters['database_port'];

        try {
            $pdo = new PDO(sprintf('mysql:dbname=%s;host=%s%s',
              $this->parameters['database_name'],
              $this->parameters['database_host'],
              empty($port) ? '' : ';port=' . $port
            ),
              $this->parameters['database_user'],
              $this->parameters['database_password'],
              array(PDO::MYSQL_ATTR_INIT_COMMAND => 'SET NAMES \'UTF8\'')
            );
        } catch(PDOException $ex) {
            echo 'Nem lehet csatlakozni a MySQL szerverhez';
            exit;
        }

        $parts= explode('-', $pdo->getAttribute(PDO::ATTR_SERVER_VERSION));

        return array('real' => $parts[0], 'params' => $this->parameters['doctrine.server_version']);
    }

    protected function executeCommand($command, $json = false)
    {
        exec($command, $out, $rcode);
        $output = $json ?
            (empty($out) ? '' : json_decode(implode("\n", $out), true)) :
            implode("\n", $out);

        return array('code' => $rcode, 'output' =>  $output);
    }

    protected function executeWhich($file)
    {
        $result = $this->executeCommand('which '.$file);

        return $result['output'];
    }

    protected function getWhiches(array $files)
    {
        if (!is_array($files))
        {
            $files = array($files);
        }

        $result = array();
        foreach ($files as $file)
        {
            if (!is_string($file))
            {
                continue;
            }
            $which = $this->executeWhich($file);
            $result[$file] = $which;
        }

        return $result;
    }

    public function getAllWhiches()
    {
        $whiches = $this->getWhiches($this->whiches);
        foreach ($whiches as $file => $path)
        {
            if (empty($path))
            {
                $whiches[$file] = '<span style="color:red">hiányzik!</span>';
            }
        }

        return $whiches;
    }

    public function checkElastic()
    {
        $curlPath = $this->executeWhich('curl');
        if (empty($curlPath))
        {
            return false;
        }
        $result = $this->executeCommand(sprintf("$curlPath -XGET 'http://%s:%s'", $this->elasticHost, $this->elasticPort), true);
        if (empty($result))
        {
            return false;
        }

        return empty($result['output']) ? false : $result['output'];
    }

    /**
     * @return string
     */
    public function getElasticHost()
    {
        return $this->elasticHost;
    }

    /**
     * @param string $elasticHost
     * @return KunstmaanRequirements
     */
    public function setElasticHost($elasticHost)
    {
        $this->elasticHost = $elasticHost;

        return $this;
    }

    /**
     * @return string
     */
    public function getElasticPort()
    {
        return $this->elasticPort;
    }

    /**
     * @param string $elasticPort
     * @return KunstmaanRequirements
     */
    public function setElasticPort($elasticPort)
    {
        $this->elasticPort = $elasticPort;

        return $this;
    }
}
